#! /usr/bin/env python3
# -*- coding: utf-8 -*-

from dataclasses import dataclass
from functools import cache
import json
import os
import shutil
from pathlib import Path
import re
import subprocess
import sys
from zipfile import ZipFile
import argparse

import fitz

@dataclass
class BookInfo:
    title: str
    filename: str
    citations: set

def fileinfo(file):
    filename = os.path.basename(file)
    rootdir = os.path.dirname(file)
    # lastmod = time.ctime(os.path.getmtime(file))
    # creation = time.ctime(os.path.getctime(file))
    filesize = os.path.getsize(file)

    print("%s**\t%s" % (rootdir, filename))

def get_all_citations(readera_backup_filename):
    uris_to_book_infos = {}
    print(f"Reading {readera_backup_filename}")
    with ZipFile(readera_backup_filename) as backup_file:
        with backup_file.open('library.json') as f:
            data = json.load(f)

    for doc in data['docs']:
        uri = doc['uri']
        doc_data = doc['data']
        try:
            book_title = doc_data['doc_title']
        except KeyError:
            book_title = doc_data['doc_file_name_title']
        doc_links = doc['links']
        # assert len(doc_links) <= 1, doc_links
        try:
            book_filename = doc_links[0]['file_name']
        except IndexError:
            book_filename = None
        book_info = BookInfo(book_title, book_filename, set())
        uris_to_book_infos[uri] = book_info
        for citation in doc['citations']:
            try:
                note_extra = citation['note_extra']
            except KeyError:
                note_extra = None
            book_info.citations.add((citation['note_body'], citation['note_page']+citation['note_index'], note_extra))

    return uris_to_book_infos

def verify_citations_complete():
    """
    Check all ReadEra backup files in the current dir. Collect all citations.
    For each backup file, show whether it has all citations or which are missing.
    """
    all_uris_to_book_infos = {}
    readera_backups_to_map = {}
    for readera_backup_filename in sorted(Path(os.path.expanduser(args.readera_backup_path)).glob('ReadEra*bak'), reverse=True):
        uris_to_book_infos = get_all_citations(readera_backup_filename)
        readera_backups_to_map[readera_backup_filename] = uris_to_book_infos
        for uri, book_info in uris_to_book_infos.items():
            try:
                all_uris_to_book_infos[uri].citations.update(book_info.citations)
            except KeyError:
                all_uris_to_book_infos[uri] = book_info

    for readera_backup_filename, uris_to_book_infos in readera_backups_to_map.items():
        print(f"Checking {readera_backup_filename}")
        if uris_to_book_infos == all_uris_to_book_infos:
            print(f"  Contains all citations")
        else:
            for all_uri, all_book_info in all_uris_to_book_infos.items():
                try:
                    book_citations = uris_to_book_infos[all_uri].citations
                    for citation in all_book_info:
                        if citation not in book_citations:
                            print(f"  Missing citation: {all_book_info.title} / {citation}")
                except KeyError:
                    print(f"  Missing title {all_book_info.title}")
                    raise

def show_titles(readera_backup_filename):
    uris_to_book_infos = get_all_citations(readera_backup_filename)
    for book_info in sorted(uris_to_book_infos.values(), key=lambda book_info: book_info.title):
        if len(book_info.citations) > 0:
            print(f"{book_info.title}, Citations: {len(book_info.citations)}")

def get_citations_by_file(readera_backup_filename, book_filename):
    print(book_filename) # DEBUG
    uris_to_book_infos = get_all_citations(readera_backup_filename)
    # print("!!!!!!!!!",uris_to_book_infos.values()) # DEBUG
    for book_info in uris_to_book_infos.values():
        # print(book_info.filename) # DEBUG
        if book_info.filename == book_filename:
            return book_info
    return None

def show_citations_for_book(readera_backup_filename, book):
    if Path(book).is_file():
        book_info = get_citations_by_file(readera_backup_filename, book)
        print(book_info) # DEBUG
    else:
        uris_to_book_infos = get_all_citations(readera_backup_filename)
        for book_info in uris_to_book_infos.values():
            if book in book_info.title:
                break
        else:
            book_info = None

    if not book_info:
        print(f"Book not found")
        sys.exit(1)

    print(f"Book: {book_info.title}")
    for citation in sorted(book_info.citations, key=lambda item: item[1]):
        print(f"- {citation[0]}")
        print()

def tokenize(text):
    LANGS = [
        'ÁáČčĎďÉéĚěÍíŇňÓóŘřŠšŤťÚúŮůÝýŽž',   # Czech
        'ÄäÖöÜüẞß',                         # German
        'ĄąĆćĘęŁłŃńÓóŚśŹźŻż',               # Polish
        'À-ú',                              # Portuguese
    ]
    pattern = r'''[A-Za-zА-Яа-я0-9!?.,;:'"{langs}]'''.format(langs=''.join(LANGS))
    return re.findall(pattern, text)
    # return re.findall(r'''[A-Za-zА-Яа-я0-9!?.,;:'"]''', text)

def find_in(text: str, span: str) -> tuple[int, int, str]:
    # Returns (start_index_of_match, end_index_of_match, remainder of span that was not matched)
    # If a remainder is returned, the match was not complete but ended at the end of the text.
    # When no prefix of span could be found, start_index_of_match and end_index_of_match are None.
    try:
        match_index = text.index(span)
        return match_index, match_index + len(span) - 1, None
    except ValueError:
        for i in range(1, len(span)):
            subspan = span[:-i]
            if text.endswith(subspan):
                return len(text) - len(subspan), len(text) - 1, span[len(subspan):]
    return None, None, span

def add_citations_to_pdf(pdf_filename, citations):
    doc = fitz.open(pdf_filename)
    pages = [(page, page.get_textpage(flags=fitz.TEXT_MEDIABOX_CLIP)) for page in doc.pages()]

    page_index = page_index_last_found = 0
    num_found = num_not_found = 0

    @cache
    def get_textpage_words(page_index) -> tuple[str, list[tuple[int, int, int, int]]]:
        words = []
        coords = []
        for word_info in pages[page_index][1].extractWORDS():
            word = word_info[4]
            word_tokenized = tokenize(word)
            words += word_tokenized
            coords += [word_info[:4]] * len(word_tokenized)
        return ''.join(words), coords

    for citation, _, note in sorted(citations, key=lambda item: item[1]):
        citation_parts = citation.split('\n')
        for citation_part in citation_parts:
            citation_string = ''.join(tokenize(citation_part))
            remainder = citation_string
            highlights = []
            while page_index < len(pages):
                page, _ = pages[page_index]
                textpage_string, char_coords = get_textpage_words(page_index)

                match_start, match_end, remainder = find_in(textpage_string, remainder)
                print(match_start) # DEBUG
                if match_start is None:
                    remainder = citation_string
                    highlights = []
                else:
                    if len(highlights) > 0 and match_start > 0:
                        # This is a partial match which had a partial match on the previous page. But it
                        # does not start at the beginning of the page, so it is not a true continuation.
                        # - Ignore match from previous page
                        # - Check current page for the full citation
                        remainder = citation_string
                        highlights = []
                        continue
                    else:
                        highlights.append((page, fitz.Point(char_coords[match_start][:2]),
                                           fitz.Point(char_coords[match_end][2:])))

                if remainder:
                    page_index += 1
                else:
                    for page, start_coords, stop_coords in highlights:
                        annot = page.add_highlight_annot(start=start_coords, stop=stop_coords)
                        if note is not None:
                            # page.add_text_annot(start_coords - fitz.Point(8, 16), note)
                            # annot.parent.insert_text(annot.rect.br, note)
                            annot.set_info(content=note)
                            annot.update()
                    page_index_last_found = page_index
                    num_found += 1
                    break
            else:
                print(f"Citation not found: {citation_part=}")
                num_not_found += 1
                page_index = page_index_last_found

    doc.saveIncr()

    print(f"Citations found: {num_found}")
    if num_not_found > 0:
        print(f"Citations not found: {num_not_found}")
        if '--debug' in sys.argv:
            with open('book.txt', 'w') as f:
                for _, textpage in pages:
                    print(textpage.extractText().encode(), file=f)
                    print(file=f)
        return False
    return True

def book_to_pdf(book_filename, pdf_filename):
    # Only really tested with epub
    # Possibly add --embed-all-fonts --subset-embedded-font
    subprocess.check_call(['ebook-convert', book_filename, pdf_filename])

def make_highlighted_pdf(readera_backup_filename, book_filename):
    book_info = get_citations_by_file(readera_backup_filename, book_filename)

    if not book_info:
        print(f"Book {book_filename} not found in readera's database")
        sys.exit(1)

    book_filename_keyword = Path(book_filename).with_stem(Path(book_filename).stem+'__note')

    # Check if file exist
    # Check in working directory
    for root, dirnames, filenames in os.walk(os.path.expanduser(args.working_directory)):
        for f in filenames:
            if f == str(book_filename):
                if (args.with_keywords):
                    shutil.copy(book_filename, book_filename_keyword)
                    success = add_citations_to_pdf(book_filename_keyword, book_info.citations)
                else:
                    success = add_citations_to_pdf(book_filename, book_info.citations)
                print(f"Produced highlighted file: {book_filename}")
                if success:
                    print('OK')
                    return
                else:
                    print('ERROR')
                    sys.exit(1)

    # Check in readera's data path
    for root, dirnames, filenames in os.walk(os.path.expanduser(args.readera_data_path)):
        for f in filenames:
            if f == str(book_filename):
                print(os.path.join(root, f))
                shutil.copy(os.path.join(root, f), os.path.expanduser(args.working_directory))

                if (args.with_keywords):
                    shutil.copy(book_filename, book_filename_keyword)
                    success = add_citations_to_pdf(book_filename_keyword, book_info.citations)
                else:
                    success = add_citations_to_pdf(book_filename, book_info.citations)

                print(f"Produced highlighted file: {book_filename}")
                if success:
                    print('OK')
                else:
                    print('ERROR')
                    sys.exit(1)

# Parsing
parser = argparse.ArgumentParser(description="Readera Highlighter")

parser.add_argument(
    '--verify-citations-complete',
    action = 'store_true',
    help = 'checks all backup files in the backup directory and shows which have all citations'
)

parser.add_argument(
    '--show-titles',
    action = 'store_true',
    help = 'show all books with citations'
)

parser.add_argument(
    '--add-highlights',
    help = 'add highlights from ReadEra backup'
)

parser.add_argument(
    '--show-citations',
    help = 'show citations'
)

parser.add_argument(
    '--readera-backup-path',
    default = '.',
    help = 'path for backup files of Readera; the current directory by default'
)

parser.add_argument(
    '--readera-data-path',
    default = '.',
    help = 'path for data files of Readera; the current directory by default'
)

parser.add_argument(
    '--working-directory',
    default = '.',
    help = 'path for working book files; the current directory by default'
)

parser.add_argument(
    '--with-keywords',
    action = 'store_true',
    default = 'true',
    help = 'add keyword to filename'
)

args = parser.parse_args()
print(args) # DEBUG

if args.verify_citations_complete == 1:
    verify_citations_complete()
else:
    readera_backup_filename = os.getenv('READERA_BACKUP')
    if readera_backup_filename is None:
        readera_backup_filenames = tuple(Path(os.path.expanduser(args.readera_backup_path)).glob('ReadEra*.bak'))
        if len(readera_backup_filenames) == 0:
            print('Did not find any ReadEra backup in current directory')
            sys.exit(1)
        else:
            readera_backup_filename = max(readera_backup_filenames, key=lambda f: f.stat().st_mtime)
    print(f"Using {readera_backup_filename}")
    if args.show_titles == 1:
        show_titles(readera_backup_filename)
    elif args.show_citations is not None:
        book_title = args.show_citations
        show_citations_for_book(readera_backup_filename, book_title)
    elif args.add_highlights is not None:
        book_filename = args.add_highlights
        make_highlighted_pdf(readera_backup_filename, book_filename)
    else:
        sys.exit(1)
